#summary 本文介绍Zz中的FrontController(前端控制器).


= 一个小故事引出的设计 =

有一个软件开发团队，其结构是这样的:
  * 一个项目经理 (我们认为他啥事都不知道)
  * 三个小组，每个小组一个leader,做一些简单的事
  * 三个小组下各有5个开发人员。
现在一个用户来了一个需求，因为项目经理不知道谁能做这件事，就把三个小组组长叫过来，情况可能有以下几种
  * 问第一个
    # 我们组不能做
      * 再问下一个
        # 又出现这4种请况   
    # 我们组能做
      * 那你们组做了吧
    # 我们组某某能做，但是他现在需要`***`条件
      * 那你把条件修改一下，做了吧
    # 我们组不能做，但是我可以修改一下`***`条件，其它组可以做
       * 那你把条件修改一下,再给我吧，我再从第一个开始问，看谁能做.
如果到最后谁都不能做，这个需求就做不了。出现服务不存在(404).

FrontController 就相当项目经理,他知道用户需求(用户请求uri),但并不知道谁来做这事，但他知道他有三个leader,同时，他也不知道三个leader谁能做，所以只能一个一个问。三个leader相当路由控制器，他们要做的事，就是看这个小组谁能做这事或者修改一下条件，自己或者他人就知道做了.

Zz中Controller System的设计是按这种思路来设计的。

在FrontController重点理解以下代码段

{{{
        int i = 0;
        while (!request.isDispatched() && i++<100) {
            for(Abstract router : this.routers ) {
                if (router.match()) {
                    break;
                }
            }
        }
}}}

  * router.match()返回true,只表示leader说这事我们组能做，并分发出去了。但不代表真的那个人能做
  * isDispatched表示这件事真的有人接受并做了。因为leader分发出去给成员(用户控制器),有可能这个人做不了。所以他会把这个变量设为false.
  * 最多问100轮，如果还没有做，就没有办法了.(一般不会出现这种况)


= FrontController 特点 =

  * 他是全局单例，不能重写。通过ZzApp.getFrontController()可以取到
  * init方法中增加了一个侦听，用来动态增加路由控制器
 